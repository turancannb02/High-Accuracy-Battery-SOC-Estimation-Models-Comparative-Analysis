# -*- coding: utf-8 -*-
"""Battery - RNN - 20240517.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HP8p0WaFFFl2425k4YA4WhYABB6p9hgl
"""

# Gerekli kütüphaneleri yüklüyorum
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import StandardScaler
import sys

# Dataset yolunu ayarlıyorum
sys.path.append('/content/drive/MyDrive/BATTERY DATASET - GITHUB/TEC-reduced-model-main/tec_reduced_model')
from process_experimental_data import import_thermal_data

# Verileri yüklüyorum
T_values = [0, 10, 25]
Crates_values = [0.5, 1, 2]
all_data = pd.DataFrame()

for T in T_values:
    for Crate in Crates_values:
        try:
            cell_data_dict = import_thermal_data(Crate, T)
            for cell_id, df in cell_data_dict.items():
                selected_columns = ["Voltage [V]", "Current [A]", "AhAccu [Ah]", "WhAccu [Wh]", "Watt [W]", "Temp Cell [degC]", "Time [s]"]
                df = df[selected_columns].astype(float)
                all_data = pd.concat([all_data, df])
        except ValueError as e:
            print(f"Error processing data for C-rate {Crate}, Temperature {T}: {e}")

# Veri ön işleme
selected_columns = ["Voltage [V]", "Current [A]", "AhAccu [Ah]", "WhAccu [Wh]", "Watt [W]", "Temp Cell [degC]"]
all_data_updated = all_data[selected_columns].astype(float)

# 'AhAccu [Ah]' sütununu sona taşıyorum
column_to_move = 'AhAccu [Ah]'
column_series = all_data_updated.pop(column_to_move)
all_data_updated[column_to_move] = column_series

# Veriyi eğitim ve test olarak bölüyorum
all_data_updated_train = all_data_updated[:1053529]
all_data_updated_test = all_data_updated[1053529:]

# Veriyi ölçeklendirmek için StandardScaler kullanıyorum
scaler = StandardScaler()
X_train = scaler.fit_transform(all_data_updated_train.iloc[:, :-1])
y_train = all_data_updated_train.iloc[:, -1].values
X_test = scaler.transform(all_data_updated_test.iloc[:, :-1])
y_test = all_data_updated_test.iloc[:, -1].values

# Sekanslar oluşturuyorum
sequence_length = 5
def create_sequences(X, y, seq_length):
    X_seq, y_seq = [], []
    for i in range(len(X) - seq_length):
        X_seq.append(X[i: i + seq_length])
        y_seq.append(y[i + seq_length - 1])
    return np.array(X_seq), np.array(y_seq)

X_train_seq, y_train_seq = create_sequences(X_train, y_train, sequence_length)
X_test_seq, y_test_seq = create_sequences(X_test, y_test, sequence_length)

# Tensörlere dönüştürüyorum ve DataLoader oluşturuyorum
train_dataset = TensorDataset(torch.Tensor(X_train_seq), torch.Tensor(y_train_seq).unsqueeze(1))
test_dataset = TensorDataset(torch.Tensor(X_test_seq), torch.Tensor(y_test_seq).unsqueeze(1))
train_loader = DataLoader(train_dataset, batch_size=512, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=128)

# RNN modelini tanımlıyorum
class RNNRegressor(nn.Module):
    def __init__(self, n_features, n_targets, n_hidden=64, n_layers=2, dropout=0.1):
        super(RNNRegressor, self).__init__()
        self.lstm = nn.LSTM(input_size=n_features, hidden_size=n_hidden, num_layers=n_layers, dropout=dropout, batch_first=True)
        self.fc = nn.Linear(n_hidden, n_targets)

    def forward(self, x):
        x, _ = self.lstm(x)
        x = x[:, -1, :]
        x = self.fc(x)
        return x

# Modeli oluşturuyorum
model = RNNRegressor(n_features=5, n_targets=1)
criterion = nn.MSELoss()
optimizer = torch.optim.RMSprop(model.parameters(), lr=0.001, weight_decay=1e-5, momentum=0.9)

# Erken durdurma sınıfını tanımlıyorum
class EarlyStopping:
    def __init__(self, patience=3, verbose=True, delta=0):
        self.patience = patience
        self.verbose = verbose
        self.delta = delta
        self.best_score = None
        self.early_stop = False
        self.counter = 0

    def __call__(self, val_loss, model):
        score = -val_loss
        if self.best_score is None:
            self.best_score = score
        elif score < self.best_score + self.delta:
            self.counter += 1
            if self.verbose:
                print(f'EarlyStopping counter: {self.counter} out of {self.patience}')
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = score
            self.counter = 0

# Erken durdurmayı başlatıyorum
early_stopping = EarlyStopping(patience=3, verbose=True)

train_losses = []
test_losses = []

# Modeli eğitiyorum
for epoch in range(15):
    model.train()
    total_loss = 0
    for data, target in train_loader:
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, target)
        loss.backward()
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
        optimizer.step()
        total_loss += loss.item()
    train_loss = total_loss / len(train_loader)
    train_losses.append(train_loss)

    model.eval()
    test_loss = 0
    with torch.no_grad():
        for data, target in test_loader:
            output = model(data)
            test_loss += criterion(output, target).item()
    test_loss /= len(test_loader)
    test_losses.append(test_loss)

    print(f"Epoch [{epoch+1}/15], Train Loss: {train_loss}, Test Loss: {test_loss}")

    # Erken durdurmayı kontrol ediyorum
    early_stopping(test_loss, model)
    if early_stopping.early_stop:
        print("Early stopping triggered")
        break

# Eğitim ve test kayıplarını görselleştiriyorum
plt.figure(figsize=(10, 5))
plt.plot(train_losses, label='Training Loss')
plt.plot(test_losses, label='Testing Loss')
plt.title('Training and Testing Losses')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Modeli değerlendiriyorum
model.eval()
y_true_list = []
y_pred_list = []
test_loss = 0
with torch.no_grad():
    for data, target in test_loader:
        output = model(data)
        loss = criterion(output, target)
        test_loss += loss.item()
        y_true_list.extend(target.detach().numpy())
        y_pred_list.extend(output.detach().numpy())

y_true = np.array(y_true_list)
y_pred = np.array(y_pred_list)
average_test_loss = test_loss / len(test_loader)
mse = mean_squared_error(y_true, y_pred)
rmse = np.sqrt(mse)

print(f"Average Test Loss: {average_test_loss}")
print(f"Mean Squared Error (MSE): {mse}")
print(f"Root Mean Squared Error (RMSE): {rmse}")

# Tahminler ve gerçek değerleri görselleştiriyorum
plt.figure(figsize=(10, 6))
plt.plot(y_true, label='Actual')
plt.plot(y_pred, label='Predicted')
plt.xlabel('Sample')
plt.ylabel('AhAccu [Ah]')
plt.title('RNN Predictions vs. Actual Values')
plt.legend()
plt.show()

# Eğitim veri setini pandas DataFrame'e dönüştürüyorum
train_df = pd.DataFrame(X_train, columns=["Voltage [V]", "Current [A]", "WhAccu [Wh]", "Watt [W]", "Temp Cell [degC]"])

# 'AhAccu [Ah]' sütununu ekliyorum
train_df['AhAccu [Ah]'] = y_train

# Korelasyon matrisini hesaplıyorum
corr_matrix = train_df.corr()

# Korelasyon matrisini görselleştiriyorum
plt.figure(figsize=(10, 6))
sns.heatmap(corr_matrix, annot=True, cmap='YlGn', fmt=".2f", linewidths=.5)
plt.title("Korelasyon Matrisi")
plt.show()

# Detaylı bir zoom ile tahminler ve gerçek değerler arasındaki farkı inceliyorum
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import mean_squared_error

# 'Actual' ve 'Predicted' verilerini çiziyorum
plt.figure(figsize=(10, 6), dpi=300)
plt.plot(y_true, label='Actual', marker='o', linestyle='-', markersize=4, linewidth=1, alpha=0.8)
plt.plot(y_pred, label='Predicted', marker='x', linestyle='--', markersize=4, linewidth=1, alpha=0.8)
plt.xlabel('Sample', fontsize=14)
plt.ylabel('AhAccu [Ah]', fontsize=14)
plt.title('RNN Predictions vs. Actual Values', fontsize=16)
plt.legend(fontsize=12)
plt.grid(True)
plt.tight_layout()
plt.show()

from mpl_toolkits.axes_grid1.inset_locator import inset_axes

# Ana plot ayarları
fig, ax = plt.subplots(figsize=(10, 6), dpi=300)
ax.plot(y_true, label='Actual', linestyle='-', linewidth=1, alpha=0.8)
ax.plot(y_pred, label='Predicted', linestyle='--', linewidth=1, alpha=0.8)
ax.set_xlabel('Sample', fontsize=14)
ax.set_ylabel('AhAccu [Ah]', fontsize=14)
ax.set_title('RNN Predictions vs. Actual Values', fontsize=16)
ax.legend(fontsize=12)
ax.grid(True)

# İç plot ayarları
axins = inset_axes(ax, width="30%", height="30%", loc=1)
axins.plot(y_true[50000:51000], linestyle='-', linewidth=1, alpha=0.8)
axins.plot(y_pred[50000:51000], linestyle='--', linewidth=1, alpha=0.8)
axins.set_title('Detail at Sample 50000-51000')
axins.set_xlabel('Sample')
axins.set_ylabel('AhAccu [Ah]')
axins.grid(True)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

# Örnek veri ayarları
x = range(200000)
y_true = np.sin(np.linspace(0, 50, 200000))
y_pred = np.sin(np.linspace(0, 50, 200000)) + np.random.normal(0, 0.1, 200000)

# Ana plot
fig, ax = plt.subplots(figsize=(12, 7))
ax.plot(x, y_true, label='Actual', color='blue', linewidth=1.5)
ax.plot(x, y_pred, label='Predicted', color='orange', linestyle='--', linewidth=1.5)
ax.set_title('RNN Predictions vs. Actual Values')
ax.set_xlabel('Sample')
ax.set_ylabel('AhAccu [Ah]')
ax.legend()

# İç plot ekleme
zoom_start = 50000
zoom_end = 51000
axins = inset_axes(ax, width="20%", height="20%", loc=2)
axins.plot(x[zoom_start:zoom_end], y_true[zoom_start:zoom_end], color='blue', linewidth=1.5)
axins.plot(x[zoom_start:zoom_end], y_pred[zoom_start:zoom_end], color='orange', linestyle='--', linewidth=1.5)
axins.set_title('Zoom on Cycle 306')
axins.set_xlim(zoom_start, zoom_end)
axins.set_ylim(min(y_true[zoom_start:zoom_end])-0.1, max(y_true[zoom_start:zoom_end])+0.1)

# Kritik nokta ekleme
critical_point = 50500
axins.plot(critical_point, y_true[critical_point], 'ro')

plt.show()

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

# 3D plot için verileri hazırlıyorum
time_steps = np.arange(len(y_true))
y_true = np.array(y_true)
y_pred = np.array(y_pred)

fig = plt.figure(figsize=(12, 6))
ax = fig.add_subplot(111, projection='3d')

# 3D çizim yapıyorum
ax.plot(time_steps, y_true, zs=0, zdir='z', label='Actual')
ax.plot(time_steps, y_pred, zs=1, zdir='z', label='Predicted')

# Etiketler ve başlıklar ekliyorum
ax.set_xlabel('Time')
ax.set_ylabel('Actual Value')
ax.set_zlabel('Predicted Value')
ax.legend()

plt.show()
